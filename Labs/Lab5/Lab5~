CSCI 260 Fall 2014: Lab 5: Red Black Trees

DUE: Part 1: Wed Oct 15 11:00 am
DUE: Part 2: Mon Oct 27 11:00 am

In this lab, you are to implement a Dictionary ADT by adapting your Binary Search Tree code into Red-Black trees. Copy your BST makefile and .cpp files into a new directory before you begin changing your code.

The project produces a link-based Red-Black Tree. A Red-Black tree is a BST (keys are ordered so that for any node in the tree, all the nodes in its left subtree have key value less than or equal to the key of the node, and all keys in the right subtree have key value greater than or equal to the key of the node). The trees are kept approximately balances using Red-Black insert and remove. Insert codes is well covered in the (see notes ).

Part 1

Make a null node (leaf) with colour black and use in tree.

You will have to change the struct of the node to accommodate "colour".
Change the struct to add a parent pointer "parent". Update your insert and delete so that parent pointers are updated as required.
Change your "debugprint" so that parent->key, colour, left->key and right->key are also printed (keys of NO_NODE should be written as N). Your output should now look like this:
Enter your command choice (D, P, H, I, Q, R, or S)
p
The tree contents are:
2:c (5 b N N)
5:a (N b 2 7)
7:b (5 b N N)


Note that you should also have a line break before the start of your listing of nodes, to improve readability.
You will also implement a top-down (i.e., pre-order) print that it gives the tree contents in pre-order; it is then easier for you to tell what your tree looks like. You can add this as a new option to your menu; however, leave "P" as the option for the in-order print, for testing purposes, and add an option "A" for this alternative print function. The output should look like the "P" option output, but with a list of its children's keys or with "N" if the child is NULL. This will allow you to determine the tree structure. Your output should look like this:

Enter your command choice (A, D, P, H, I, Q, R, or S)
a
The tree contents are:
5:a (N b 2 7)
2:c (5 b N N)
7:b (5 b N N)


It will simplify your code for the boundary conditions (when the node is NO_NODE) if, instead of having NO_NODE being 0, NO_NODE is a sentinal node that has a left and a right child, each of which are 0 or NO_NODE, depending on your design choices, and has colour black. Only one sentinal node is necessary; all pointers to empty leaf children can point to the same sentinal node. Sentinal nodes should not appear in the debugprint or alternate debugprint output. Data is kept only at the internal nodes.
Implement "Left-Rotate" and "Right-Rotate". Debug it. How will you be able to tell if your code works correctly? Write a short paragraph on how you tested it, and provide this as separate text file submission.
To submit the files to me:

Part 1: Submit the directory that contains:

    the makefile
    the code files, with your name and the instructions for compiling at the top
    A sample input file for a binary tree that with at least 20 nodes, and with 4 removes. The file should be of a form so that "./testapp < filenamehere" will give suitable input to build such a tree.
    Your text file about how you tested your rotations.

Everything but the data files and the makefile should bear your complete name and student number. Code should be well-documented and well designed.
Part 2

    Understand how "insert" works for red-black trees. Change your "insert" so that it balances as necessary for red-black trees. Debug this before continuing on to your "remove".
    Understand how "remove" works for red-black trees. Code up your algorithm for "remove", and debug.
    Test it. You can use the testapp.C file provided if you like, or write your own testing routines. However, your interface should be the same as that expected by testapp.C
    Run the resulting program, which you have called "testapp" by using the -o option of the g++ compilation command in the makefile, type
    ./testapp

    Document the code. The stubs provided are only minimally documented. Don't take them as a model; you should bring them up to standard.

    To submit the files to me:

    Part 2: Submit the directory that contains:
        the makefile
        the code files, with your name and the instructions for compiling at the top
        A sample input file for a binary tree that with at least 20 nodes, and with 4 removes. The file should be of a form so that "./testapp < filenamehere" will give suitable input to build such a tree.
    Everything but the data files and the makefile should bear your complete name and student number. Code should be well-documented and well designed.
    To submit, you should have a directory that contains ONLY and ALL the files to submit. While in that directory (i.e., if the directory is called lab4 you should "cd lab4"), type the following command on the command line:
    /home/faculty/gpruesse/260/bin/submit.sh .
    Note that the command ends with "space period", a.k.a " ." The submit command archives whatever arguments are passed on the command line, and "." means the current directory. 



Files from the bst lab:
testapp.cpp
bst.h
bst.cpp (stub)
makefile


